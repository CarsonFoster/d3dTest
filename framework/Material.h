#ifndef CWF_MATERIAL_H
#define CWF_MATERIAL_H

#include "Graphics.h"
#include "ShaderStage.h"
#include "Submaterial.h"
#include "lib/DirectXTK/DDSTextureLoader.h"
#include <cstddef> // for std::byte
#include <cstring> // for std::memcpy
#include <d3d11.h>
#include <initializer_list>
#include <memory> // std::unique_ptr
#include <optional>
#include <vector>
#include <wrl.h>

/*
* A material is a class-like object, representing a type of DirectX object that uses the same shader,resources,etc.
* You can add as many meshes as you want; they all just have to be of the same material.
* An übershader is one large shader that uses conditionals to determine which code to execute; this means that we
* don't have to load multiple shaders, which is expensive.
*/

template <class Vertex, typename Index>
class Material {
private:
	struct Shader {
		const void* pByteCode;
		size_t length;
		bool bind;
	};

	struct ConstantBuffer {
		const void* pBuffer;
		size_t length;
		ShaderStage stage;
		bool readOnly;
		ConstantBuffer(const void* p, size_t l, ShaderStage s, bool r) 
			: pBuffer{ p }, length{ l }, stage{ s }, readOnly{ r }{}
	};
private:
	// set by user
	D3D11_PRIMITIVE_TOPOLOGY m_primitiveTopology;
	const D3D11_INPUT_ELEMENT_DESC* m_pDescriptions;
	size_t m_numberOfDescs;
	DXGI_FORMAT m_indexFormat;
	std::vector<Vertex> m_vtx;
	std::vector<Index> m_idx;
	std::vector<std::unique_ptr<std::byte[]>> m_copiedConstantBuffers;
	std::vector<std::unique_ptr<std::byte[], Graphics::AlignedDeleter>> m_copiedAlignedConstantBuffers;
	std::vector<ConstantBuffer> m_cBuffers;
	Shader m_vs;
	std::optional<Shader> m_oPS;
	std::optional<Microsoft::WRL::ComPtr<ID3D11RenderTargetView>> m_oPRTV;
	std::optional<Microsoft::WRL::ComPtr<ID3D11DepthStencilView>> m_oPDSV;
	std::optional<D3D11_VIEWPORT> m_oVP;
	std::optional<Graphics::Texture2D> m_oTex2D;

	// need to maintain pointers to these for GPU
	struct {
		struct {
			Microsoft::WRL::ComPtr<ID3D11Buffer> pBuffer{};
			UINT stride{};
			UINT offset{};
		} vertex{};
		struct {
			Microsoft::WRL::ComPtr<ID3D11Buffer> pBuffer{};
		} index{};
		struct {
			std::vector<Microsoft::WRL::ComPtr<ID3D11Buffer>> vertexBuffers{};
			std::vector<Microsoft::WRL::ComPtr<ID3D11Buffer>> pixelBuffers{};
			std::vector<ID3D11Buffer*> vertexRawBuffers{};
			std::vector<ID3D11Buffer*> pixelRawBuffers{};
		} constant{};
		struct {
			Microsoft::WRL::ComPtr<ID3D11VertexShader> pVertex{};
			Microsoft::WRL::ComPtr<ID3D11PixelShader> pPixel{};
		} shader{};
		struct {
			Microsoft::WRL::ComPtr<ID3D11ShaderResourceView> pSRView{};
			Microsoft::WRL::ComPtr<ID3D11SamplerState> pSampler{};
		} texture2D{};
		Microsoft::WRL::ComPtr<ID3D11InputLayout> pLayout{};
	} Data{};

	// generated by DirectX
	Microsoft::WRL::ComPtr<ID3D11CommandList> m_pCmdList;

public:
	Material(DXGI_FORMAT indexFormat) : m_primitiveTopology{}, m_numberOfDescs{}, m_indexFormat{ indexFormat } {}

	DXGI_FORMAT getIndexFormat() const noexcept {
		return m_indexFormat;
	}

	// do not interact with DirectX
	void setTopology(D3D11_PRIMITIVE_TOPOLOGY primitiveTopology) noexcept {
		m_primitiveTopology = primitiveTopology;
	}

	void setInputLayout(const D3D11_INPUT_ELEMENT_DESC* pDescriptions, size_t size) noexcept {
		m_pDescriptions = pDescriptions;
		m_numberOfDescs = size;
	}

	void addMesh(std::initializer_list<Vertex> vertices, std::initializer_list<Index> indices) noexcept {
		m_vtx.insert(m_vtx.cend(), vertices);
		m_idx.insert(m_idx.cend(), indices);
	}

	void addMesh(std::vector<Vertex> vertices, std::vector<Index> indices) noexcept {
		m_vtx.insert(m_vtx.cend(), vertices.begin(), vertices.end());
		m_idx.insert(m_idx.cend(), indices.begin(), indices.end());
	}

	void addMesh(const Graphics::IndexedVertexList<Vertex, Index>& mesh) noexcept {
		m_vtx.insert(m_vtx.cend(), mesh.vertices.begin(), mesh.vertices.end());
		m_idx.insert(m_idx.cend(), mesh.indices.begin(), mesh.indices.end());
	}

	void addConstantBuffer(const void* pBuffer, size_t byteWidth, ShaderStage stage, bool readOnly = true) noexcept {
		m_cBuffers.emplace_back(pBuffer, byteWidth, stage, readOnly);
	}

	void copyConstantBuffer(const void* pBuffer, size_t byteWidth, ShaderStage stage, bool readOnly = true, bool aligned = false) {
		if (!aligned) {
			auto copiedBuffer = std::make_unique<std::byte[]>(byteWidth);
			std::memcpy(copiedBuffer.get(), pBuffer, byteWidth);
			m_cBuffers.emplace_back(copiedBuffer.get(), byteWidth, stage, readOnly);
			m_copiedConstantBuffers.push_back(std::move(copiedBuffer));
		} else {
			void* raw = _aligned_malloc(byteWidth, 16);
			std::memcpy(raw, pBuffer, byteWidth);
			m_cBuffers.emplace_back(raw, byteWidth, stage, readOnly);
			m_copiedAlignedConstantBuffers.push_back(std::unique_ptr<std::byte[], Graphics::AlignedDeleter>{ reinterpret_cast<std::byte*>(raw) });
		}
	}

	void updateCopyConstantBuffer(size_t index, const Graphics& gfx, const void* pBuffer, size_t byteWidth) { // expensive
		if (index >= m_cBuffers.size() || m_cBuffers[index].readOnly || !m_pCmdList) return;
		Microsoft::WRL::ComPtr<ID3D11DeviceContext> pImmediateContext{ gfx.getImmediateContext() };
		D3D11_MAPPED_SUBRESOURCE mappedResource{ 0 };
		ID3D11Buffer* pConstantBuffer{};
		switch (m_cBuffers[index].stage) {
		case ShaderStage::VERTEX:
			pConstantBuffer = Data.constant.vertexRawBuffers[index];
			break;
		case ShaderStage::PIXEL:
			pConstantBuffer = Data.constant.pixelRawBuffers[index];
			break;
		default:
#ifndef NDEBUG
			OutputDebugStringW(L"Update your other stage switch, dumb dumb.\n");
#endif
			return;
		}
		THROW_IF_FAILED(gfx, 
			pImmediateContext->Map(pConstantBuffer, 0, D3D11_MAP_WRITE_DISCARD, 0, &mappedResource));
		std::memcpy(mappedResource.pData, pBuffer, byteWidth);
		pImmediateContext->Unmap(pConstantBuffer, 0);
	}

	void setVertexShader(const void* pByteCode, size_t length, bool bind = true) noexcept {
		m_vs = { pByteCode, length, bind };
	}

	void setPixelShader(const void* pByteCode, size_t length) noexcept {								   // optional
		m_oPS = { pByteCode, length, true };
	}
	
	void setRenderTarget(Microsoft::WRL::ComPtr<ID3D11RenderTargetView> renderTarget, 
		Microsoft::WRL::ComPtr<ID3D11DepthStencilView> zbuffer) noexcept {								   // optional
		
		m_oPRTV = renderTarget;
		m_oPDSV = zbuffer;
	}

	void setViewport(D3D11_VIEWPORT viewport) noexcept {                                                   // optional
		m_oVP = viewport;
	}

	void setViewport(float topLeftX, float topLeftY, float width, float height) noexcept {
		D3D11_VIEWPORT vp{};
		vp.TopLeftX = topLeftX;
		vp.TopLeftY = topLeftY;
		vp.Width = width;
		vp.Height = height;
		vp.MinDepth = 0.0f;
		vp.MaxDepth = 1.0f;
		m_oVP = vp;
	}

	void setTexture2D(Graphics::Texture2D texture) {
		m_oTex2D = texture;
	}

	void setupPipeline(const Graphics& gfx) {
		if (m_pCmdList) return; // do not re-generate resources

		Microsoft::WRL::ComPtr<ID3D11Device> pDevice{ gfx.getDevice() };
		
		Microsoft::WRL::ComPtr<ID3D11DeviceContext> pDeferred;
		THROW_IF_FAILED(gfx, pDevice->CreateDeferredContext(0, &pDeferred));

		setupPipeline(gfx, pDeferred, m_pCmdList);
	}

	//  should call in another thread for optimal performance
	void setupPipeline(const Graphics& gfx, Microsoft::WRL::ComPtr<ID3D11DeviceContext> pDeferred, 
		Microsoft::WRL::ComPtr<ID3D11CommandList>& pListToFill, bool submaterialCalling = false) {
		Microsoft::WRL::ComPtr<ID3D11Device> pDevice{ gfx.getDevice() };

		// vertex buffer
		if (!submaterialCalling) {
			D3D11_BUFFER_DESC vtxDesc{};
			vtxDesc.ByteWidth = m_vtx.size() * sizeof(Vertex);
			vtxDesc.Usage = D3D11_USAGE_DEFAULT;
			vtxDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
			vtxDesc.CPUAccessFlags = 0u;
			vtxDesc.MiscFlags = 0u;
			vtxDesc.StructureByteStride = sizeof(Vertex);

			D3D11_SUBRESOURCE_DATA vtxData{};
			vtxData.pSysMem = m_vtx.data();

			THROW_IF_FAILED(gfx, pDevice->CreateBuffer(&vtxDesc, &vtxData, &Data.vertex.pBuffer));

			Data.vertex.stride = sizeof(Vertex);
			Data.vertex.offset = 0u;

			pDeferred->IASetVertexBuffers(0u, 1u, Data.vertex.pBuffer.GetAddressOf(), &Data.vertex.stride, &Data.vertex.offset);
		}

		// index buffer
		if (!submaterialCalling) {
			D3D11_BUFFER_DESC idxDesc{};
			idxDesc.ByteWidth = m_idx.size() * sizeof(Index);
			idxDesc.Usage = D3D11_USAGE_DEFAULT;
			idxDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
			idxDesc.CPUAccessFlags = 0u;
			idxDesc.MiscFlags = 0u;
			idxDesc.StructureByteStride = sizeof(Index);

			D3D11_SUBRESOURCE_DATA idxData{};
			idxData.pSysMem = m_idx.data();

			THROW_IF_FAILED(gfx, pDevice->CreateBuffer(&idxDesc, &idxData, &Data.index.pBuffer));

			pDeferred->IASetIndexBuffer(Data.index.pBuffer.Get(), m_indexFormat, 0u);
		}

		// constant buffer
		if (!submaterialCalling) {
			for (ConstantBuffer& cb : m_cBuffers) {
				D3D11_BUFFER_DESC cbDesc{};
				cbDesc.ByteWidth = cb.length;
				cbDesc.Usage = (cb.readOnly ? D3D11_USAGE_DEFAULT : D3D11_USAGE_DYNAMIC);
				cbDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
				cbDesc.CPUAccessFlags = (cb.readOnly ? 0u : D3D11_CPU_ACCESS_WRITE);
				cbDesc.MiscFlags = 0u;
				cbDesc.StructureByteStride = 0u;

				D3D11_SUBRESOURCE_DATA cbData{};
				cbData.pSysMem = cb.pBuffer;

				Microsoft::WRL::ComPtr<ID3D11Buffer> pCBuff;
				THROW_IF_FAILED(gfx, pDevice->CreateBuffer(&cbDesc, &cbData, &pCBuff));

				switch (cb.stage) {
				case ShaderStage::VERTEX:
					Data.constant.vertexBuffers.push_back(pCBuff);
					break;
				case ShaderStage::PIXEL:
					Data.constant.pixelBuffers.push_back(pCBuff);
					break;
#ifndef NDEBUG
				default:
					OutputDebugStringW(L"Update your ShaderStage switch, dumb dumb.");
#endif
				}
			}
			for (auto& comPtr : Data.constant.vertexBuffers)
				Data.constant.vertexRawBuffers.push_back(comPtr.Get());
			for (auto& comPtr : Data.constant.pixelBuffers)
				Data.constant.pixelRawBuffers.push_back(comPtr.Get());
			if (!Data.constant.vertexRawBuffers.empty())
				pDeferred->VSSetConstantBuffers(0u, Data.constant.vertexRawBuffers.size(), Data.constant.vertexRawBuffers.data());
			if (!Data.constant.pixelRawBuffers.empty())
				pDeferred->VSSetConstantBuffers(0u, Data.constant.pixelRawBuffers.size(), Data.constant.pixelRawBuffers.data());
		}

		// primitive topology
		{
			pDeferred->IASetPrimitiveTopology(m_primitiveTopology);
		}

		// vertex shader
		{
			if (m_vs.bind) {
				if (!Data.shader.pVertex) // if already generated, skip
					THROW_IF_FAILED(gfx, pDevice->CreateVertexShader(m_vs.pByteCode, m_vs.length, nullptr, &Data.shader.pVertex));
				pDeferred->VSSetShader(Data.shader.pVertex.Get(), nullptr, 0u);
			}
		}

		// pixel shader
		{
			if (m_oPS) {
				if (!Data.shader.pPixel) // if already generated, skip
					THROW_IF_FAILED(gfx, pDevice->CreatePixelShader(m_oPS->pByteCode, m_oPS->length, nullptr, &Data.shader.pPixel));
				pDeferred->PSSetShader(Data.shader.pPixel.Get(), nullptr, 0u);
			}
		}

		// input layout
		{
			if (!Data.pLayout) // if already generated, skip
				THROW_IF_FAILED(gfx, pDevice->CreateInputLayout(m_pDescriptions, m_numberOfDescs, m_vs.pByteCode, m_vs.length, &Data.pLayout));
			pDeferred->IASetInputLayout(Data.pLayout.Get());
		}

		// render target and z buffer
		{
			if (m_oPRTV) {
				pDeferred->OMSetRenderTargets(1u, m_oPRTV->GetAddressOf(), m_oPDSV->Get());
			}
		}

		// viewport
		{
			if (m_oVP) {
				pDeferred->RSSetViewports(1u, &(*m_oVP));
			}
		}

		// texture
		{
			if (m_oTex2D) {
				bool valid_type{ true };
				if (std::holds_alternative<Graphics::Texture2D::RawData>(m_oTex2D->content)) {
					Graphics::Texture2D::RawData& rd{ std::get<Graphics::Texture2D::RawData>(m_oTex2D->content) };
					D3D11_TEXTURE2D_DESC textureDesc{};
					textureDesc.Width = rd.width;
					textureDesc.Height = rd.height;
					textureDesc.MipLevels = rd.mipLevels;
					textureDesc.ArraySize = rd.arraySize;
					textureDesc.Format = rd.format;
					textureDesc.SampleDesc.Count = rd.sampleCount;
					textureDesc.SampleDesc.Quality = rd.sampleQuality;
					textureDesc.Usage = D3D11_USAGE_DEFAULT;
					textureDesc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
					textureDesc.CPUAccessFlags = rd.cpuAccessFlags;
					textureDesc.MiscFlags = rd.miscFlags;

					D3D11_SUBRESOURCE_DATA textureData{};
					textureData.pSysMem = rd.pData;
					textureData.SysMemPitch = rd.pitch;

					Microsoft::WRL::ComPtr<ID3D11Texture2D> pTexture;
					THROW_IF_FAILED(gfx, pDevice->CreateTexture2D(&textureDesc, &textureData, &pTexture));

					D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc{};
					srvDesc.Format = rd.format;
					srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
					srvDesc.Texture2D.MostDetailedMip = rd.mostDetailedMip;
					srvDesc.Texture2D.MipLevels = rd.mipLevels;

					THROW_IF_FAILED(gfx, pDevice->CreateShaderResourceView(pTexture.Get(), &srvDesc, &Data.texture2D.pSRView));

					pDeferred->PSSetShaderResources(0u, 1u, Data.texture2D.pSRView.GetAddressOf());
				} else if (std::holds_alternative<Graphics::Texture2D::File>(m_oTex2D->content)) {
					Graphics::Texture2D::File& file{ std::get<Graphics::Texture2D::File>(m_oTex2D->content) };
					THROW_IF_FAILED(gfx,
						DirectX::CreateDDSTextureFromFile(pDevice.Get(), file.filename, nullptr, &Data.texture2D.pSRView)
					);
					pDeferred->PSSetShaderResources(0u, 1u, Data.texture2D.pSRView.GetAddressOf());
				} else {
					valid_type = false;
#ifndef NDEBUG
					OutputDebugStringW(L"Texture2D variant had an unexpected type (update your if statement)");
#endif
				}

				if (valid_type) { // only execute if the type was valid
					D3D11_SAMPLER_DESC samplerDesc{};
					samplerDesc.Filter = m_oTex2D->sampler.filter;
					samplerDesc.AddressU = m_oTex2D->sampler.u;
					samplerDesc.AddressV = m_oTex2D->sampler.v;
					samplerDesc.AddressW = m_oTex2D->sampler.w;
					samplerDesc.MipLODBias = m_oTex2D->sampler.mipLODBias;
					samplerDesc.MaxAnisotropy = m_oTex2D->sampler.maxAnisotropy;
					samplerDesc.ComparisonFunc = m_oTex2D->sampler.comparisonFunc;
					samplerDesc.BorderColor[0] = m_oTex2D->sampler.borderColor.r;
					samplerDesc.BorderColor[1] = m_oTex2D->sampler.borderColor.g;
					samplerDesc.BorderColor[2] = m_oTex2D->sampler.borderColor.b;
					samplerDesc.BorderColor[3] = m_oTex2D->sampler.borderColor.a;
					samplerDesc.MinLOD = m_oTex2D->sampler.minLOD;
					samplerDesc.MaxLOD = m_oTex2D->sampler.maxLOD;

					THROW_IF_FAILED(gfx, pDevice->CreateSamplerState(&samplerDesc, &Data.texture2D.pSampler));

					pDeferred->PSSetSamplers(0u, 1u, Data.texture2D.pSampler.GetAddressOf());
				}
			}
		}

		// draw command
		pDeferred->DrawIndexed(m_idx.size(), 0u, 0);

		// generate command list
		THROW_IF_FAILED(gfx, pDeferred->FinishCommandList(FALSE, &pListToFill));
	}

	// call on main thread
	void draw(const Graphics& gfx) {
		gfx.getImmediateContext()->ExecuteCommandList(m_pCmdList.Get(), FALSE);
	}
};

#endif