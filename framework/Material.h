#ifndef CWF_MATERIAL_H
#define CWF_MATERIAL_H

#include "Graphics.h"
#include "Submaterial.h"
#include <d3d11.h>
#include <initializer_list>
#include <memory>
#include <optional>
#include <vector>
#include <wrl.h>

/*
* A material is a class-like object, representing a type of DirectX object that uses the same shader,resources,etc.
* You can add as many meshes as you want; they all just have to be of the same material.
* An übershader is one large shader that uses conditionals to determine which code to execute; this means that we
* don't have to load multiple shaders, which is expensive.
*/

template <class Vertex, typename Index>
class Material {
private:
	struct Shader {
		const void* pByteCode;
		size_t length;
		bool bind;
	};

	struct ConstantBuffer {
		const void* pBuffer;
		size_t length;
		bool readOnly;
	};
private:
	// set by user
	D3D11_PRIMITIVE_TOPOLOGY pt;
	std::shared_ptr<D3D11_INPUT_ELEMENT_DESC[]> pDescs;
	size_t numberOfDescs;
	DXGI_FORMAT idxFormat;
	std::vector<Vertex> vtx;
	std::vector<Index> idx;
	std::vector<ConstantBuffer> cBuffs;
	std::vector<Submaterial<Vertex, Index>> subs;
	Shader vs;
	std::optional<Shader> oPS;
	std::optional<Microsoft::WRL::ComPtr<ID3D11RenderTargetView>> oPrtv;
	std::optional<Microsoft::WRL::ComPtr<ID3D11DepthStencilView>> oPdsv;
	std::optional<D3D11_VIEWPORT> oVP;

	// generated by DirectX
	Microsoft::WRL::ComPtr<ID3D11CommandList> pCmdList;

public:
	Material(DXGI_FORMAT indexFormat) : pt{}, pDescs{}, numberOfDescs{}, idxFormat{ indexFormat }, vtx{}, idx{},
		cBuffs{}, subs{}, vs{}, oPS{}, oPrtv{}, oPdsv{}, oVP{}, pCmdList{} {}

	// do not interact with DirectX
	void setTopology(D3D11_PRIMITIVE_TOPOLOGY topology) noexcept {
		pt = topology;
	}

	void setInputLayout(std::shared_ptr<D3D11_INPUT_ELEMENT_DESC[]> pDescriptions, size_t size) noexcept {
		pDescs = pDescriptions;
		numberOfDescs = size;
	}

	void addMesh(std::initializer_list<Vertex> vertices, std::initializer_list<Index> indices) noexcept {
		vtx.insert(vtx.cend(), vertices);
		idx.insert(idx.cend(), indices);
	}

	void addConstantBuffer(const void* pBuffer, size_t byteWidth, bool readOnly = true) noexcept {
		cBuffs.emplace_back({ pBuffer, byteWidth, readOnly });
	}

	void setVertexShader(const void* pByteCode, size_t length, bool bind = true) noexcept {
		vs = { pByteCode, length, bind };
	}

	void setPixelShader(const void* pByteCode, size_t length) noexcept {								   // optional
		oPS = { pByteCode, length, true };
	}
	
	void setRenderTarget(Microsoft::WRL::ComPtr<ID3D11RenderTargetView> renderTarget, 
		Microsoft::WRL::ComPtr<ID3D11DepthStencilView> zbuffer) noexcept {								   // optional
		
		oPrtv = renderTarget;
		oPdsv = zbuffer;
	}

	void setViewport(D3D11_VIEWPORT viewport) noexcept {                                                   // optional
		vp = viewport;
	}

	Submaterial<Vertex, Index>& createSubmaterial() noexcept {
		subs.emplace_back();
		return subs[subs.size() - 1];
	}


	//  should call in another thread for optimal performance
	void setupPipeline(const Graphics& gfx) {
		if (pCmdList) return; // do not re-generate resources
		Microsoft::WRL::ComPtr<ID3D11Device> pDevice{ gfx.getDevice() };
		
		Microsoft::WRL::ComPtr<ID3D11DeviceContext> pDeferred;
		THROW_IF_FAILED(gfx, pDevice->CreateDeferredContext(0, &pDeferred));

		// vertex buffer
		{
			D3D11_BUFFER_DESC vtxDesc{};
			vtxDesc.ByteWidth = vtx.size() * sizeof(Vertex);
			vtxDesc.Usage = D3D11_USAGE_DEFAULT;
			vtxDesc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
			vtxDesc.CPUAccessFlags = 0u;
			vtxDesc.MiscFlags = 0u;
			vtxDesc.StructureByteStride = sizeof(Vertex);

			D3D11_SUBRESOURCE_DATA vtxData{};
			vtxData.pSysMem = vtx.data();

			Microsoft::WRL::ComPtr<ID3D11Buffer> pVtxBuffer;
			THROW_IF_FAILED(gfx, pDevice->CreateBuffer(&vtxDesc, &vtxData, &pVtxBuffer));

			UINT stride{ sizeof(Vertex) };
			UINT offset{ 0u };

			pDeferred->IASetVertexBuffers(0u, 1u, pVtxBuffer.GetAddressOf(), &stride, &offset);
		}

		// index buffer
		{
			D3D11_BUFFER_DESC idxDesc{};
			idxDesc.ByteWidth = idx.size() * sizeof(Index);
			idxDesc.Usage = D3D11_USAGE_DEFAULT;
			idxDesc.BindFlags = D3D11_BIND_INDEX_BUFFER;
			idxDesc.CPUAccessFlags = 0u;
			idxDesc.MiscFlags = 0u;
			idxDesc.StructureByteStride = sizeof(Index);

			D3D11_SUBRESOURCE_DATA idxData{};
			idxData.pSysMem = idx.data();

			Microsoft::WRL::ComPtr<ID3D11Buffer> pIdxBuffer;
			THROW_IF_FAILED(gfx, pDevice->CreateBuffer(&idxDesc, &idxData, &pIdxBuffer));

			pDeferred->IASetIndexBuffer(pIdxBuffer.Get(), idxFormat, 0u);
		}

		// primitive topology
		{
			pDeferred->IASetPrimitiveTopology(pt);
		}

		// vertex shader
		{
			if (vs.bind) {
				Microsoft::WRL::ComPtr<ID3D11VertexShader> pVtxShader;
				THROW_IF_FAILED(gfx, pDevice->CreateVertexShader(vs.pByteCode, vs.length, nullptr, pVtxShader));
				pDeferred->VSSetShader(pVtxShader.Get(), nullptr, 0u);
			}
		}

		// pixel shader
		{
			if (oPS) {
				Microsoft::WRL::ComPtr<ID3D11PixelShader> pPixelShader;
				THROW_IF_FAILED(gfx, pDevice->CreatePixelShader(oPS->pByteCode, oPS->length, nullptr, pPixelShader));
				pDeferred->PSSetShader(pPixelShader.Get(), nullptr, 0u);
			}
		}

		// input layout
		{
			Microsoft::WRL::ComPtr<ID3D11InputLayout> pLayout;
			THROW_IF_FAILED(gfx, pDevice->CreateInputLayout(pDescs.get(), numberOfDescs, vs.pByteCode, vs.length, &pLayout));
			pDeferred->IASetInputLayout(pLayout.Get());
		}

		// render target and z buffer
		{
			if (oPrtv) {
				pDeferred->OMSetRenderTargets(1u, oPrtv->GetAddressOf(), oPdsv->Get());
			}
		}

		// viewport
		{
			if (oVP) {
				pDeferred->RSSetViewports(1u, &(*oVP));
			}
		}

		// draw command
		pDeferred->DrawIndexed(idx.size(), 0u, 0);

		// generate command list
		THROW_IF_FAILED(gfx, pDeferred->FinishCommandList(FALSE, &pCmdList));
	}

	// call on main thread
	void draw(Microsoft::WRL::ComPtr<ID3D11DeviceContext> pImmediateContext) {
		pImmediateContext->ExecuteCommandList(pCommandList.Get(), FALSE);
	}
};

#endif